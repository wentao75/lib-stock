{"version":3,"file":"lib-stock.js","sources":["src/util.js","src/transaction-engine.js","src/momentum-breakthrough.js","src/simulator.js","src/stoploss.js"],"sourcesContent":["function formatFxstr(num) {\n    return num.toLocaleString(\"zh-CN\"); //, { style: \"currency\", currency: \"CNY\" });\n}\n\nexport { formatFxstr };\n","// const moment = require(\"moment\");\n// const _ = require(\"lodash\");\n// import moment from \"moment\";\nimport _ from \"lodash\";\nimport { formatFxstr } from \"./util\";\nimport debugpkg from \"debug\";\n\nconst debug = debugpkg(\"trans\");\n\n/**\n * 主处理过程\n * 1. 当前持仓是否需要止损，options.stoploss指定算法执行止损，如果止损立刻清算并记录\n * 2. 卖出算法执行是否卖出，如果卖出，清算并记录\n * 3. 买入算法执行是否买入，如果买入，清算并记录\n *\n * TODO：主过程可以考虑持有多次买入，这样只要记录相应的总投入即可\n *\n * @param {*} tradeDate 当前计算交易日\n * @param {*} index 当前日股票数据索引\n * @param {*} stockData 股票数据信息\n * @param {*} stockInfo 股票信息\n * @param {*} capitalData 账户信息\n * @param {*} options 算法参数\n */\nasync function executeTransaction(\n    tradeMethod,\n    tradeDate,\n    index,\n    stockData,\n    stockInfo,\n    capitalData,\n    options\n) {\n    let translog = null;\n    // 首先检查卖出\n    // 所有算法首先检查并处理止损\n    // 检查是否需要止损\n    if (options.stoploss) {\n        translog = options.stoploss.checkStoplossTransaction(\n            capitalData && capitalData.stock,\n            tradeDate,\n            index,\n            stockData,\n            options\n        );\n        if (\n            executeCapitalSettlement(\n                tradeDate,\n                stockInfo,\n                translog,\n                capitalData,\n                options\n            )\n        ) {\n            debug(\n                `卖出止损：${tradeDate.format(\"YYYYMMDD\")}，价格：${formatFxstr(\n                    translog.price\n                )}元，数量：${\n                    translog.count / 100\n                }手，总价：${translog.total.toFixed(\n                    2\n                )}元[佣金${translog.commission.toFixed(\n                    2\n                )}元，过户费${translog.fee.toFixed(\n                    2\n                )}，印花税${translog.duty.toFixed(2)}元], ${translog.memo}`\n            );\n            // return translog;\n        }\n    }\n\n    // debug(\"执行卖出检查\");\n    translog = tradeMethod.checkSellTransaction(\n        capitalData && capitalData.stock,\n        tradeDate,\n        index,\n        stockData,\n        options\n    );\n    if (\n        executeCapitalSettlement(\n            tradeDate,\n            stockInfo,\n            translog,\n            capitalData,\n            options\n        )\n    ) {\n        debug(\n            `卖出交易：${tradeDate.format(\n                \"YYYYMMDD\"\n            )}，价格：${translog.price.toFixed(2)}元，数量：${\n                translog.count / 100\n            }手，总价：${translog.total.toFixed(\n                2\n            )}元[佣金${translog.commission.toFixed(\n                2\n            )}元，过户费${translog.fee.toFixed(\n                2\n            )}，印花税${translog.duty.toFixed(2)}元], ${translog.memo}`\n        );\n        // return translog;\n    }\n\n    // 检查是否仍然有持仓\n    if (capitalData && capitalData.stock && capitalData.stock.count > 0) return;\n    // 执行买入\n    // debug(\"执行买入检查\");\n    let cash = capitalData.balance;\n    if (options.fixCash) cash = options.initBalance;\n    translog = tradeMethod.checkBuyTransaction(\n        cash,\n        stockInfo,\n        tradeDate,\n        index,\n        stockData,\n        options\n    );\n    // debug(`买入结果：%o`, translog);\n    if (\n        executeCapitalSettlement(\n            tradeDate,\n            stockInfo,\n            translog,\n            capitalData,\n            options\n        )\n    ) {\n        debug(\n            `买入交易：${tradeDate.format(\n                \"YYYYMMDD\"\n            )}，价格：${translog.price.toFixed(2)}元，数量：${\n                translog.count / 100\n            }手，总价：${translog.total.toFixed(\n                2\n            )}元[佣金${translog.commission.toFixed(\n                2\n            )}元，过户费${translog.fee.toFixed(\n                2\n            )}，印花税${translog.duty.toFixed(2)}元], ${translog.memo}`\n        );\n        // debug(`股票信息：%o`, stockInfo);\n        // debug(`账户信息：%o`, capitalData);\n        // return translog;\n    }\n}\n\n/**\n * 根据交易记录完成账户清算\n * @param {*} tradeDate 交易日期\n * @param {*} stockInfo 股票信息\n * @param {*} translog 交易记录\n * @param {*} capitalData 账户数据\n */\nfunction executeCapitalSettlement(\n    tradeDate,\n    stockInfo,\n    translog,\n    capitalData,\n    options\n) {\n    // debug(`执行清算 %o`, translog);\n    if (_.isEmpty(translog)) return false;\n    // 检查当前提供的交易是否可以进行，主要是针对累计账户买卖\b模式下买入交易是否会造成余额不足\n    if (!options.fixCash && translog.total + capitalData.balance < 0) {\n        debug(\n            `账户余额${capitalData.balance}不足(${\n                translog.total\n            })，无法完成清算，交易取消! 交易信息: ${\n                translog.type === \"buy\" ? \"买入\" : \"卖出\"\n            }${stockInfo.ts_code} ${translog.count}股，价格${\n                translog.price\n            }，共计${translog.total}元[含佣金${translog.commission}元，过户费${\n                translog.fee\n            }，印花税${translog.duty}元]`\n        );\n        return false;\n    }\n\n    // 处理交易信息\n    capitalData.balance += translog.total;\n    // 如果当前买入，stock中放置持股信息和买入交易日志，只有卖出发生时才合并生成一条交易记录，包含两个部分\n    if (translog.type === \"buy\") {\n        capitalData.stock = {\n            info: stockInfo,\n            count: translog.count,\n            price: translog.price,\n            buy: translog,\n        };\n    } else {\n        let settledlog = {\n            tradeDate: translog.tradeDate,\n            profit: capitalData.stock.buy.total + translog.total,\n            income:\n                translog.count * translog.price -\n                capitalData.stock.count * capitalData.stock.price,\n            buy: capitalData.stock.buy,\n            sell: translog,\n        };\n        capitalData.stock = {\n            info: null,\n            count: 0,\n            price: 0,\n        };\n        capitalData.transactions.push(settledlog);\n    }\n    // debug(\"完成清算！\");\n    return true;\n}\n\n/**\n * 创建指定日期和股票信息的卖出交易\n * @param {*} stockInfo\n * @param {*} tradeDate\n * @param {*} tradeDateIndex\n * @param {*} count\n * @param {*} price\n * @param {*} memo\n */\nfunction createSellTransaction(\n    stockInfo,\n    tradeDate,\n    tradeDateIndex,\n    count,\n    price,\n    methodType,\n    memo\n) {\n    // 计算费用\n    let total = calculateTransactionFee(false, stockInfo, count, price);\n    // 创建卖出交易记录\n    return {\n        date: tradeDate.format(\"YYYYMMDD\"),\n        dateIndex: tradeDateIndex,\n        type: \"sell\",\n        count,\n        price,\n        total: total.total,\n        amount: total.amount,\n        fee: total.fee,\n        commission: total.commission,\n        duty: total.duty,\n        methodType,\n        memo,\n    };\n}\n\n/**\n * 构建买入交易信息\n * @param {*} stockInfo 股票信息\n * @param {*} tradeDate 交易日期\n * @param {*} tradeDateIndex 交易日期索引（方便用于计算交易日数）\n * @param {*} balance 可用余额\n * @param {*} price 买入价格\n * @param {*} memo 交易备注\n */\nfunction createBuyTransaction(\n    stockInfo,\n    tradeDate,\n    tradeDateIndex,\n    balance,\n    price,\n    methodType,\n    memo\n) {\n    // 计算费用\n    let count = parseInt(balance / price / 100) * 100;\n    // 最小交易单位为1手，资金不足放弃！\n    if (count < 100) return;\n    let total = calculateTransactionFee(true, stockInfo, count, price);\n    while (total.total + balance < 0) {\n        count -= 100;\n        if (count < 100) return;\n        total = calculateTransactionFee(true, stockInfo, count, price);\n    }\n    // 创建买入交易记录\n    return {\n        date: tradeDate.format(\"YYYYMMDD\"),\n        dateIndex: tradeDateIndex,\n        type: \"buy\",\n        count: count,\n        price,\n        total: total.total,\n        amount: total.amount,\n        fee: total.fee,\n        commission: total.commission,\n        duty: total.duty,\n        methodType,\n        memo,\n    };\n}\n\n/**\n * 计算交易价格和费用\n * @param {boolean}} buy 买卖标记\n * @param {*} stockInfo 股票信息\n * @param {*} count 买卖数量\n * @param {*} price 买卖单价\n */\nfunction calculateTransactionFee(buy, stockInfo, count, price) {\n    let amount = count * price;\n    let commission = (amount * 0.25) / 1000;\n    let fee = 0.0;\n    let duty = 0.0;\n    if (stockInfo.exchange === \"SSE\") {\n        // 上海，过户费千分之0.2\n        fee += (amount * 0.02) / 1000;\n    } else if (stockInfo.exchange === \"SZSE\") {\n        // 深圳，无\n    }\n    // 印花税，仅对卖方收取\n    if (!buy) {\n        duty += (amount * 1) / 1000;\n    }\n\n    let total = 0.0;\n    if (buy) {\n        total = 0 - (amount + commission + fee + duty);\n    } else {\n        total = amount - commission - fee - duty;\n    }\n\n    return { total, amount, commission, fee, duty };\n}\n\nfunction parseCapital(capitalData) {\n    if (_.isEmpty(capitalData)) return;\n    // 账户信息中主要需分析交易过程，正常都是为一次买入，一次卖出，这样作为一组交易，获得一次盈利结果\n    let count = capitalData.transactions.length;\n    let count_win = 0;\n    let total_win = 0;\n    let count_loss = 0;\n    let total_loss = 0;\n    let total_profit = 0;\n    let total_fee = 0;\n    let max_profit = 0;\n    let max_loss = 0;\n    let average_profit = 0;\n    let average_win = 0;\n    let average_loss = 0;\n    let max_wintimes = 0; // 连续盈利次数\n    let max_losstimes = 0; // 连续亏损次数\n    let max_windays = 0;\n    let max_lossdays = 0;\n    let average_windays = 0;\n    let average_lossdays = 0;\n    // {times: 总次数, win_times: 盈利次数, loss_times: 损失次数}\n    let selltypes = {};\n    //let selltype_times = {};\n\n    // 收益率：表示单位成本的收入比例\n    let ror_win = 0;\n    let ror_loss = 0;\n    let ror = 0;\n\n    let tmp_cost = 0;\n    let tmp_cost_win = 0;\n    let tmp_cost_loss = 0;\n\n    let currentType = 0;\n    let tmp_times = 0;\n    let tmp_windays = 0;\n    let tmp_lossdays = 0;\n    for (let log of capitalData.transactions) {\n        let days = log.sell.dateIndex - log.buy.dateIndex + 1;\n\n        let selltype = selltypes[log.sell.methodType];\n        if (!selltype) {\n            selltypes[log.sell.methodType] = {\n                times: 1,\n                win_times: 0,\n                loss_times: 0,\n            };\n        }\n        selltypes[log.sell.methodType].times += 1;\n\n        if (log.profit >= 0) {\n            count_win++;\n            total_win += log.profit;\n            tmp_cost_win += -log.buy.total;\n            if (max_profit < log.profit) max_profit = log.profit;\n\n            tmp_windays += days;\n            if (max_windays < days) max_windays = days;\n\n            // 连续计数\n            if (currentType === 1) {\n                tmp_times++;\n            } else {\n                if (currentType === -1) {\n                    if (max_losstimes < tmp_times) max_losstimes = tmp_times;\n                }\n                // 初始化\n                currentType = 1;\n                tmp_times = 1;\n            }\n\n            selltypes[log.sell.methodType].win_times += 1;\n        } else {\n            count_loss++;\n            total_loss += log.profit;\n            tmp_cost_loss += -log.buy.total;\n            if (max_loss > log.profit) max_loss = log.profit;\n\n            tmp_lossdays += days;\n            if (max_lossdays < days) max_lossdays = days;\n\n            // 连续计数\n            if (currentType === -1) {\n                tmp_times++;\n            } else {\n                if (currentType === 1) {\n                    if (max_wintimes < tmp_times) max_wintimes = tmp_times;\n                }\n                // 初始化\n                currentType = -1;\n                tmp_times = 1;\n            }\n\n            selltypes[log.sell.methodType].loss_times += 1;\n        }\n\n        total_profit += log.profit;\n        total_fee +=\n            log.buy.commission +\n            log.buy.fee +\n            log.buy.duty +\n            (log.sell.commission + log.sell.fee + log.sell.duty);\n        tmp_cost += -log.buy.total;\n    }\n\n    if (currentType === 1) {\n        if (max_wintimes < tmp_times) max_wintimes = tmp_times;\n    } else if (currentType === -1) {\n        if (max_losstimes < tmp_times) max_losstimes = tmp_times;\n    }\n\n    average_profit = total_profit / count;\n    average_win = total_win / count_win;\n    average_loss = -total_loss / count_loss;\n\n    average_windays = Number((tmp_windays / count_win).toFixed(1));\n    average_lossdays = Number((tmp_lossdays / count_loss).toFixed(1));\n\n    ror = total_profit / tmp_cost;\n    ror_win = total_win / tmp_cost_win;\n    ror_loss = total_loss / tmp_cost_loss;\n\n    return {\n        count,\n        total_profit,\n        total_fee,\n        count_win,\n        total_win,\n        count_loss,\n        total_loss,\n        max_profit,\n        max_loss,\n        average_profit,\n        average_win,\n        average_loss,\n        max_wintimes,\n        max_losstimes,\n        max_windays,\n        max_lossdays,\n        average_windays,\n        average_lossdays,\n        selltypes,\n\n        ror,\n        ror_win,\n        ror_loss,\n    };\n}\n\nfunction logCapitalReport(log, capitalData) {\n    log(\n        `******************************************************************************************`\n    );\n    // log(\n    //     \"*                                                                                                                      *\"\n    // );\n    if (capitalData.stock && capitalData.stock.count > 0) {\n        log(\n            `  账户价值 ${formatFxstr(\n                capitalData.balance +\n                    capitalData.stock.count * capitalData.stock.price\n            )}元  【余额 ${formatFxstr(capitalData.balance)}元, 持股：${\n                capitalData.stock.info.name\n            } ${formatFxstr(\n                capitalData.stock.count * capitalData.stock.price\n            )}元】`\n        );\n    } else {\n        log(`  账户余额 ${formatFxstr(capitalData.balance)}元`);\n    }\n\n    let capitalResult = parseCapital(capitalData);\n    // log(``);\n    log(\n        `  总净利润：${formatFxstr(capitalResult.total_profit)},  收益率 ${(\n            capitalResult.ror * 100\n        ).toFixed(2)}%`\n    );\n    log(\n        `  毛利润： ${formatFxstr(\n            capitalResult.total_win\n        )},  总亏损：${formatFxstr(capitalResult.total_loss)}`\n    );\n    log(\n        `  盈利收益率： ${(capitalResult.ror_win * 100).toFixed(\n            2\n        )}%,  亏损收益率：${(capitalResult.ror_loss * 100).toFixed(2)}%`\n    );\n    log(\"\");\n    log(\n        `  总交易次数： ${capitalResult.count},  利润率：${(\n            (capitalResult.count_win * 100) /\n            capitalResult.count\n        ).toFixed(1)}%`\n    );\n    log(\n        `  总盈利次数： ${capitalResult.count_win},  总亏损次数：${capitalResult.count_loss}`\n    );\n    log(\"\");\n    log(\n        `  最大单笔盈利： ${formatFxstr(\n            capitalResult.max_profit\n        )},  最大单笔亏损：${formatFxstr(capitalResult.max_loss)}`\n    );\n    log(\n        `  平均盈利： ${formatFxstr(\n            capitalResult.average_win\n        )},  平均亏损：${formatFxstr(capitalResult.average_loss)}`\n    );\n    log(\n        `  平均盈利/平均亏损： ${(\n            capitalResult.average_win / capitalResult.average_loss\n        ).toFixed(2)},  平均每笔总盈利：${formatFxstr(\n            capitalResult.average_profit\n        )}`\n    );\n    log(\"\");\n    log(\n        `  最多连续盈利次数： ${capitalResult.max_wintimes},  最多连续亏损次数：${capitalResult.max_losstimes}`\n    );\n    log(\n        `  盈利最多持有天数： ${capitalResult.max_windays},  亏损最多持有天数：${capitalResult.max_lossdays}`\n    );\n    log(\n        `  盈利平均持有天数： ${capitalResult.average_windays},  亏损平均持有天数：${capitalResult.average_lossdays}`\n    );\n\n    log(\"\");\n    for (let methodType in capitalResult.selltypes) {\n        let selltype = capitalResult.selltypes[methodType];\n        log(\n            `  卖出类型${methodType} 共${selltype.times}次,  盈利${selltype.win_times}次， 损失${selltype.loss_times}次`\n        );\n    }\n    // log(\n    //     \"*                                                                                                                      *\"\n    // );\n    log(\n        `******************************************************************************************`\n    );\n    log(\"\");\n}\n\nfunction logTransactions(log, capitalData) {\n    log(`  交易日志分析\n******************************************************************************************`);\n    for (let translog of capitalData.transactions) {\n        log(logTransaction(translog));\n    }\n    if (capitalData.stock && capitalData.stock.count > 0) {\n        let holdlog = { buy: capitalData.stock.buy };\n        log(logTransaction(holdlog));\n    }\n    log(\n        `******************************************************************************************`\n    );\n}\n\n// settledlog = {\n//     tradeDate: translog.tradeDate,\n//     profit: capitalData.stock.buy.total + translog.total,\n//     income:\n//         translog.count * translog.price -\n//         capitalData.stock.count * capitalData.stock.price,\n//     buy: capitalData.stock.buy,\n//     sell: translog,\n// };\n// trans: {\n// date: tradeDate.format(\"YYYYMMDD\"),\n// dateIndex: tradeDateIndex,\n// type: \"sell\",\n// count,\n// price,\n// total: total.total,\n// amount: total.amount,\n// fee: total.fee,\n// commission: total.commission,\n// duty: total.duty,\n// methodType,\n// memo,\n// }\nfunction logTransaction(translog) {\n    if (!translog) return \"\";\n    let buy = translog.buy;\n    let sell = translog.sell;\n    if (sell) {\n        return `收入：${formatFxstr(translog.profit)}, 持有 ${\n            sell.dateIndex - buy.dateIndex + 1\n        }天，盈利 ${(-(translog.profit * 100) / buy.total).toFixed(2)}%\n       [买入 ${buy.date}, ${formatFxstr(buy.price)}, ${\n            buy.count\n        }, ${formatFxstr(buy.total)}] \n       [卖出 ${sell.date}, ${formatFxstr(sell.price)}, ${\n            sell.count\n        }, ${formatFxstr(sell.total)}, ${sell.methodType}, ${sell.memo}]`;\n    } else {\n        // 持有未卖出\n        return `收入：---, 持有 ---天，盈利 ---\n       [买入 ${buy.date}, ${formatFxstr(buy.price)}, ${\n            buy.count\n        }, ${formatFxstr(buy.total)}]`;\n    }\n}\n\nexport default {\n    executeTransaction,\n    executeCapitalSettlement,\n    createSellTransaction,\n    createBuyTransaction,\n    calculateTransactionFee,\n    parseCapital,\n    logCapitalReport,\n    logTransactions,\n};\n","import _ from \"lodash\";\nimport engine from \"./transaction-engine\";\n\nimport debugpkg from \"debug\";\nconst debug = debugpkg(\"mmb\");\n\n/**\n * 检查买入条件\n * @param {double} balance 账户余额\n * @param {*} tradeDate 交易日期\n * @param {int} index 交易日数据索引位置\n * @param {*} stockData 数据\n * @param {*} options 算法参数\n */\nfunction checkMMBBuyTransaction(\n    balance,\n    stockInfo,\n    tradeDate,\n    index,\n    stockData,\n    options\n) {\n    if (balance <= 0) return;\n    // debug(`买入检查: ${balance}, ${tradeDate}, %o, ${index}`, stockData);\n\n    // 平均波幅的计算日数\n    let N = (options && options.N) || 1;\n    // 波幅突破的百分比\n    let P = (options && options.P) || 0.5;\n\n    let moment = 0;\n    for (let i = 0; i < N; i++) {\n        if (index - i - 1 >= 0) {\n            let tmp = stockData[index - i - 1];\n            if (options.mmbType === \"hl\") {\n                moment += tmp.high - tmp.low;\n            } else {\n                moment += tmp.high - tmp.close;\n            }\n        }\n    }\n    moment = moment / N;\n\n    let currentData = stockData[index];\n    // console.log(`跟踪信息： ${stockData.length}, ${index}`, currentData);\n    let targetPrice = currentData.open + moment * P;\n\n    debug(\n        `买入条件检查${tradeDate.format(\"YYYYMMDD\")}: ${targetPrice.toFixed(\n            2\n        )}=${currentData.open}+${moment.toFixed(2)}*${P} [o: ${\n            currentData.open\n        }, h: ${currentData.high}, l: ${currentData.low}, c: ${\n            currentData.close\n        }, d: ${currentData.trade_date}]`\n    );\n    if (currentData.high >= targetPrice && currentData.open <= targetPrice) {\n        // 执行买入交易\n        debug(`符合条件：${tradeDate.format(\"YYYYMMDD\")}`);\n        return engine.createBuyTransaction(\n            stockInfo,\n            tradeDate,\n            index,\n            balance,\n            targetPrice,\n            \"mmb\",\n            `动能突破买入 ${targetPrice.toFixed(2)} (=${\n                currentData.open\n            }+${moment.toFixed(2)}*${(P * 100).toFixed(2)}%)`\n        );\n    }\n}\n\n/**\n * 检查是否可以生成卖出交易，如果可以卖出，产生卖出交易记录\n *\n * @param {*} stock 持仓信息\n * @param {*} tradeDate 交易日\n * @param {*} index 今日数据索引位置\n * @param {*} stockData 日线数据\n * @param {*} options 算法参数\n */\nfunction checkMMBSellTransaction(stock, tradeDate, index, stockData, options) {\n    if (_.isEmpty(stock) || stock.count <= 0) return;\n\n    // 检查是否符合动能突破买入条件\n    if (\n        options.MB &&\n        !_.isEmpty(\n            checkMMBBuyTransaction(\n                options.initBalance,\n                stock.info,\n                tradeDate,\n                index,\n                stockData,\n                options\n            )\n        )\n    ) {\n        // 可以买入，那么当日保持\n        return;\n    }\n\n    let currentData = stockData[index];\n\n    // 目前有持仓，检查是否达到盈利卖出条件\n    if (options.OS && currentData.open > stock.price) {\n        // 采用第二天开盘价盈利就卖出的策略\n        debug(\n            `开盘盈利策略符合：${currentData.open.toFixed(\n                2\n            )} (> ${stock.price.toFixed(2)})`\n        );\n        return engine.createSellTransaction(\n            stock.info,\n            tradeDate,\n            index,\n            stock.count,\n            currentData.open,\n            \"mmb1\",\n            `开盘盈利卖出 ${currentData.open} (> ${stock.price.toFixed(2)})`\n        );\n    }\n\n    // 平均波幅的计算日数\n    let N = (options && options.N) || 1;\n    // 止损使用的波幅下降百分比\n    let L = (options && options.L) || 0.5;\n    // 有持仓，检查是否达到卖出条件\n    // 第一个卖出条件是买入后按照买入价格及波动数据的反向百分比设置\n    let moment = 0;\n    for (let i = 0; i < N; i++) {\n        if (index - i - 1 >= 0) {\n            let tmp = stockData[index - i - 1];\n            if (options.mmbType === \"hl\") {\n                moment += tmp.high - tmp.low;\n            } else {\n                moment += tmp.high - tmp.close;\n            }\n        }\n    }\n    moment = moment / N;\n\n    let targetPrice = currentData.open - moment * L;\n    // let targetPrice2 = stock.price - moment * L;\n    // let targetPrice =\n    //     targetPrice1 >= targetPrice2 ? targetPrice1 : targetPrice2;\n\n    if (targetPrice <= currentData.open && targetPrice >= currentData.low) {\n        // 执行波动卖出\n        return engine.createSellTransaction(\n            stock.info,\n            tradeDate,\n            index,\n            stock.count,\n            targetPrice,\n            \"mmb2\",\n            `动能突破卖出：${targetPrice.toFixed(2)} (= ${\n                currentData.open\n            }-${moment.toFixed(2)}*${L * 100}%)`\n        );\n    }\n}\n\nlet mmb = {\n    name: \"MMB\",\n    description: \"动能穿透\",\n    methodTyps: {\n        mmb: \"动能突破买入\",\n        mmb1: \"开盘盈利卖出\",\n        mmb2: \"动能突破卖出\",\n    },\n    checkBuyTransaction: checkMMBBuyTransaction,\n    checkSellTransaction: checkMMBSellTransaction,\n};\n\nexport default mmb;\n","import {\n    readStockList,\n    readStockData,\n    stockDataNames,\n} from \"@wt/lib-wtda-query\";\n\nimport moment from \"moment\";\nimport _ from \"lodash\";\nimport debugpkg from \"debug\";\n\n// import { formatFxstr } from \"./util\";\n\n// import stoploss from \"./stoploss\";\nimport mmb from \"./momentum-breakthrough\";\nimport engine from \"./transaction-engine\";\n\nconst log = console.log;\nconst debug = debugpkg(\"sim\");\n\nasync function simulate(options) {\n    // 首先根据设置获得列表，列表内容为需要进行算法计算的各个股票\n    //  TODO: 这里先读取全部的列表\n    let stockListData = await readStockList();\n    if (!stockListData || !stockListData.data) {\n        log(`没有读取到股票列表，无法处理日线数据`);\n        return;\n    }\n    let stockList = stockListData.data;\n    // 重新过滤可用的\n    stockList = await filterStockList(stockList, options);\n    log(`算法执行 ${stockList && stockList.length} 条数据`);\n    // data存放股票列表的基本信息：\n    // {\n    //      ts_code: '000001.SZ', symbol: '000001', name: '平安银行',\n    //      market: '主板', exchange: 'SZSE',\n    //      area: '深圳', industry: '银行', fullname: '平安银行股份有限公司',\n    //      enname: 'Ping An Bank Co., Ltd.', curr_type: 'CNY',\n    //      list_status: 'L', list_date: '19910403', delist_date: null, is_hs: 'S'\n    // }\n    // this.log(`%o`, stockList[0]);\n    // 后续的执行为列表的循环计算，这里的算法因为主要是CPU计算类型，只有输入和输出部分有I/O运算，因此不考虑\n\n    log(\"\");\n    // 下一步开始按照给出的数据循环进行处理\n    for (let stockItem of stockList) {\n        // this.log(`处理数据：%o`, stockItem);\n\n        // 首先读取日线信息\n        let stockData = await readStockData(\n            stockDataNames.daily,\n            stockItem.ts_code\n        );\n        // 准备资金账户数据\n        let capitalData = {\n            balance: options.initBalance, // 初始资金\n            stock: { info: null, count: 0, price: 0 }, // 持有股票信息\n            transactions: [], // 交易记录 {date: , count: 交易数量, price: 交易价格, total: 总金额, amount: 总价, fee: 交易费用, memo: 备注信息}\n        };\n        if (stockData) {\n            log(\n                `[${stockItem.ts_code}]${\n                    stockItem.name\n                } 【数据更新时间：${moment(stockData.updateTime).format(\n                    \"YYYY-MM-DD HH:mm\"\n                )}】`\n            );\n            // 日线数据条数 ${\n            //     stockData.data && stockData.data.length\n            // }, 从${stockData.startDate}到${\n            //     stockData.endDate\n            // }，\n\n            // 首先过滤历史数据，这里将日线数据调整为正常日期从历史到现在\n            stockData = await filterStockData(stockData);\n\n            // 全部数据调整为前复权后再执行计算\n            calculatePrevAdjPrice(stockData);\n\n            // 开始按照日期执行交易算法\n            let startDate = moment(\"20190101\", \"YYYYMMDD\");\n            let currentDate = null;\n            for (let index = 0; index < stockData.data.length; index++) {\n                let daily = stockData.data[index];\n                let tradeDate = moment(daily.trade_date, \"YYYYMMDD\");\n                if (_.isEmpty(currentDate)) {\n                    if (startDate.isAfter(tradeDate)) {\n                        continue;\n                    }\n                    debug(\n                        `找到开始日期，开始执行算法！${index}, ${daily.trade_date}`\n                    );\n                }\n                currentDate = tradeDate;\n                // this.log(`%o`, engine);\n                let trans = await engine.executeTransaction(\n                    mmb,\n                    currentDate,\n                    index,\n                    stockData.data,\n                    stockItem,\n                    capitalData,\n                    options\n                );\n            }\n\n            engine.logCapitalReport(log, capitalData);\n            if (options.showTrans) {\n                engine.logTransactions(log, capitalData);\n            }\n        } else {\n            log(\n                `[${stockItem.ts_code}]${stockItem.name} 没有日线数据，请检查！`\n            );\n        }\n    }\n}\n\n/**\n * 将日线数据中的历史价位根据复权因子全部处理为前复权结果，方便后续计算\n *\n * @param {*} dailyData 日线数据\n * @param {int} digits 保留位数\n */\nfunction calculatePrevAdjPrice(dailyData, digits = 2) {\n    if (dailyData && dailyData.data && dailyData.data.length > 0) {\n        dailyData.data.forEach((item) => {\n            if (item.prevadj_factor) {\n                item.open = Number(\n                    (item.open * item.prevadj_factor).toFixed(digits)\n                );\n                item.close = Number(\n                    (item.close * item.prevadj_factor).toFixed(digits)\n                );\n                item.high = Number(\n                    (item.high * item.prevadj_factor).toFixed(digits)\n                );\n                item.low = Number(\n                    (item.low * item.prevadj_factor).toFixed(digits)\n                );\n                item.pre_close = Number(\n                    (item.pre_close * item.prevadj_factor).toFixed(digits)\n                );\n                item.change = Number(\n                    (item.change * item.prevadj_factor).toFixed(digits)\n                );\n            }\n        });\n    }\n}\n\n/**\n * 这里定义一个过滤列表的接口方法，利用options来过滤后续使用的股票\n * 返回为一个符合条件的列表\n * 这里后续考虑调整一下接口定义，目前暂时简化处理\n */\nasync function filterStockList(stockList, options) {\n    // let retStockList = [];\n    return options.selectedStocks.map((tsCode) => {\n        let tmp = stockList.filter((item) => {\n            return item.ts_code === tsCode;\n        });\n        // console.log(`${tmp && tmp.length}, %o`, tmp[0]);\n        return tmp[0];\n    });\n}\n\n/**\n * 这里提供对单个数据的调整，主要应当是一些额外的数据计算添加，周期过滤等\n *\n * @param {*} stockData 股票日线数据对象\n * @param {*} options 数据过滤条件\n */\nasync function filterStockData(stockData, options) {\n    stockData.data.reverse();\n    return stockData;\n}\n\nexport default simulate;\n","// const _ = require(\"lodash\");\nimport _ from \"lodash\";\n// const engine = require(\"./transaction-engine\");\nimport engine from \"./transaction-engine\";\n\n/**\n * 检查是否需要执行止损\n * @param {*} stock 持仓信息\n * @param {*} tradeDate 交易日期\n * @param {int} index 交易日索引位置\n * @param {*} stockData 日线数据\n */\nfunction checkStoplossTransaction(stock, tradeDate, index, stockData, options) {\n    if (_.isEmpty(stock) || stock.count <= 0) return;\n    let currentData = stockData[index];\n    // 止损最大损失比例\n    let S = (options && options.S) || 0.1;\n\n    // 这里检查纯粹的百分比止损\n    let lossPrice = stock.price * (1 - S);\n    if (currentData.low <= lossPrice) {\n        // 当日价格范围达到止损值\n        return engine.createSellTransaction(\n            stock.info,\n            tradeDate,\n            index,\n            stock.count,\n            lossPrice,\n            \"stoploss\",\n            `止损 ${lossPrice.toFixed(2)} (=${stock.price.toFixed(2)}*(1-${\n                S * 100\n            }%))`\n        );\n    }\n}\n\nlet stoploss = {\n    name: \"SL\",\n    description: \"止损\",\n    methodTypes: {\n        stoploss: \"止损卖出\",\n    },\n    checkStoplossTransaction,\n};\n\nexport default stoploss;\n"],"names":["formatFxstr","num","toLocaleString","debug","debugpkg","executeCapitalSettlement","tradeDate","stockInfo","translog","capitalData","options","_","isEmpty","fixCash","total","balance","type","ts_code","count","price","commission","fee","duty","stock","info","buy","settledlog","profit","income","sell","transactions","push","calculateTransactionFee","amount","exchange","parseCapital","length","count_win","total_win","count_loss","total_loss","total_profit","total_fee","max_profit","max_loss","average_profit","average_win","average_loss","max_wintimes","max_losstimes","max_windays","max_lossdays","average_windays","average_lossdays","selltypes","ror_win","ror_loss","ror","tmp_cost","tmp_cost_win","tmp_cost_loss","currentType","tmp_times","tmp_windays","tmp_lossdays","log","days","dateIndex","methodType","times","win_times","loss_times","Number","toFixed","logTransaction","date","memo","executeTransaction","async","tradeMethod","index","stockData","stoploss","checkStoplossTransaction","format","checkSellTransaction","cash","initBalance","checkBuyTransaction","createSellTransaction","tradeDateIndex","createBuyTransaction","parseInt","logCapitalReport","name","capitalResult","selltype","logTransactions","checkMMBBuyTransaction","N","P","moment","i","tmp","mmbType","high","low","close","currentData","targetPrice","open","trade_date","engine","mmb","description","methodTyps","mmb1","mmb2","MB","OS","L","console","calculatePrevAdjPrice","dailyData","digits","data","forEach","item","prevadj_factor","pre_close","change","filterStockData","reverse","methodTypes","S","lossPrice","stockListData","readStockList","stockList","selectedStocks","map","tsCode","filter","filterStockList","stockItem","readStockData","stockDataNames","daily","updateTime","startDate","currentDate","isAfter","showTrans"],"mappings":"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"}